{"version":3,"file":"/packages/meteor-headers.js","sources":["meteor-headers/headers-common.js","meteor-headers/headers-client.js"],"names":[],"mappings":";;;;;;;;AAAA,W;AACA,U;AACA,e;AACA,sC;AACA,+B;AACA,G;AACA,4B;AACA,yB;AACA,E;AACA,C;;AAEA,uC;;;;;;;;;;;;;;;;;;;ACXA,E;AACA,0B;AACA,G;AACA,qD;;AAEA,E;AACA,sB;AACA,G;AACA,kC;;AAEA,E;AACA,uE;AACA,6D;AACA,G;AACA,mC;AACA,qB;AACA,yC;AACA,6C;AACA,qB;AACA,yB;AACA,qB;AACA,E;;AAEA,E;AACA,oE;AACA,iC;AACA,E;AACA,0E;AACA,0E;AACA,G;AACA,qB;AACA,2B;AACA,oC;AACA,gB;AACA,8B;AACA,qE;AACA,sB;AACA,c;AACA,S;AACA,oB;AACA,2C;AACA,E;AACA,E;;AAEA,E;AACA,uE;AACA,uE;AACA,mD;AACA,G;AACA,iB;AACA,+B;AACA,yC;AACA,uD;AACA,oC;AACA,uB;;AAEA,E;AACA,8B;AACA,G;AACA,gC;AACA,oB;AACA,+C;AACA,C;;AAEA,E;AACA,8C;AACA,G;AACA,4C;AACA,+C;AACA,uC;AACA,+B;AACA,6C;AACA,C","sourcesContent":["headers = {\n\tlist: {},\n\tproxyCount: 0,\n\tsetProxyCount: function(proxyCount) {\n\t\tthis.proxyCount = proxyCount;\n\t},\n\tgetProxyCount: function() {\n\t\treturn this.proxyCount;\n\t}\n}\n\nPackage.headers = { headers: headers };\n","/*\n * Generate a unique token\n */\nheaders.token = new Date().getTime() + Math.random();\n\n/*\n * Used for reactivity\n */\nheaders.dep = new Deps.Dependency;\n\n/*\n * Called after receiving all the headers, used to re-associate headers\n * with this clients livedata session (see headers-server.js)\n */\nheaders.store = function(headers) {\n\tthis.list = headers;\n\tMeteor.call('headersToken', this.token);\n \tfor (var i=0; i < this.readies.length; i++)\n \t\tthis.readies[i]();\n \tthis.readiesRun = true;\n \tthis.dep.changed();\n};\n\n/*\n * This has two completely different uses, but retains the same name\n * as this is what people expect.\n *\n * With an arg: Store a callback to be run when headersHelper.js completes\n * Without an arg: Return a reactive boolean on whether or not we're ready\n */\nheaders.readies = [];\nheaders.readiesRun = false;\nheaders.ready = function(callback) {\n\tif (callback) {\n\t\tthis.readies.push(callback);\n\t\t// Run immediately if headers.store() was already called previously\n\t\tif (this.readiesRun)\n\t\t\tcallback();\n\t} else {\n\t\tthis.dep.depend();\n\t\treturn Object.keys(this.list).length > 0;\n\t}\n};\n\n/*\n * Create another connection to retrieve our headers (see README.md for\n * why this is necessary).  Called with our unique token, the retrieved\n * code runs headers.store() above with the results\n */\n(function(d, t) {\n    var g = d.createElement(t),\n        s = d.getElementsByTagName(t)[0];\n    g.src = '/headersHelper.js?token=' + headers.token;\n    s.parentNode.insertBefore(g, s);\n}(document, 'script'));\n\n/*\n * Get a header or all headers\n */\nheaders.get = function(header) {\n \tthis.dep.depend();\n\treturn header ? this.list[header] : this.list;\n}\n\n/*\n * Get the client's IP address (see README.md)\n */\nheaders.getClientIP = function(proxyCount) {\n\tvar chain = this.get('x-ip-chain').split(',');\n\tif (typeof(proxyCount) == 'undefined')\n\t\tproxyCount = this.proxyCount;\n\treturn chain[chain.length - proxyCount - 1];\n}\n"]}