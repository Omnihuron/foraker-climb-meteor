{"version":3,"file":"/packages/meteor-headers.js","sources":["meteor-headers/headers-common.js","meteor-headers/headers-server.js"],"names":[],"mappings":";;;;;;;;AAAA,W;AACA,U;AACA,e;AACA,sC;AACA,+B;AACA,G;AACA,4B;AACA,yB;AACA,E;AACA,C;;AAEA,uC;;;;;;;;;;;;;;;;;;;ACXA,gD;;AAEA,E;AACA,+E;AACA,sE;AACA,G;AACA,uC;AACA,iB;AACA,iC;AACA,gE;AACA,2C;AACA,O;AACA,6E;AACA,yC;AACA,e;AACA,C;;AAEA,E;AACA,0E;AACA,wE;AACA,wE;AACA,4B;AACA,G;AACA,0E;AACA,8B;;AAEA,6E;AACA,oC;;AAEA,mE;AACA,yF;AACA,G;;AAEA,E;AACA,0E;AACA,0E;AACA,mE;AACA,G;AACA,gB;AACA,mC;AACA,8B;AACA,sD;AACA,6C;AACA,iC;AACA,K;AACA,G;AACA,G;;AAEA,E;AACA,4B;AACA,I;AACA,+B;AACA,2B;AACA,oE;AACA,gC;AACA,yB;;AAEA,E;AACA,8C;AACA,G;AACA,yB;AACA,qB;AACA,0C;AACA,uB;AACA,C;;AAEA,E;AACA,sD;AACA,G;AACA,mC;AACA,Y;AACA,iF;AACA,kF;AACA,kC;AACA,4C;AACA,gC;AACA,8D;AACA,C;;AAEA,gC;AACA,Y;AACA,iF;AACA,kF;AACA,kC;AACA,qD;AACA,C;;AAEA,kD;AACA,Y;AACA,iF;AACA,kF;AACA,2D;AACA,kC;AACA,wC;AACA,iC;AACA,8C;AACA,C;;AAEA,E;AACA,0E;AACA,G;AACA,qD;AACA,uC;AACA,uE;AACA,kF;AACA,qB;AACA,+C;AACA,+B;AACA,8D;AACA,yC;AACA,K;;AAEA,8D;AACA,wC;AACA,iC;AACA,8C;AACA,C","sourcesContent":["headers = {\n\tlist: {},\n\tproxyCount: 0,\n\tsetProxyCount: function(proxyCount) {\n\t\tthis.proxyCount = proxyCount;\n\t},\n\tgetProxyCount: function() {\n\t\treturn this.proxyCount;\n\t}\n}\n\nPackage.headers = { headers: headers };\n","var HEADERS_CLEANUP_TIME = 300000;  // 5 minutes\n\n/*\n * Returns an array describing the suspected IP route the connection has taken.\n * This is in order of trust, see the README.md for which value to use\n */\nfunction ipChain(headers, connection) {\n  var chain = [];\n  if (headers['x-forwarded-for'])\n    _.each(headers['x-forwarded-for'].split(','), function(ip) {\n      chain.push(ip.replace('/\\s*/g', ''));\n    });\n  if (chain.length == 0 || chain[chain.length-1] != connection.remoteAddress)\n    chain.push(connection.remoteAddress);\n  return chain;\n}\n\n/*\n * The client will request this \"script\", and send a unique token with it,\n * which we later use to re-associate the headers from this request with\n * the user's livedata session (since XHR requests only send a subset of\n * all the regular headers).\n */\nWebApp.connectHandlers.use('/headersHelper.js', function(req, res, next) {\n  var token = req.query.token;\n\n  req.headers['x-ip-chain'] = ipChain(req.headers, req.connection).join(',');\n  headers.list[token] = req.headers;\n\n  res.writeHead(200, { 'Content-type': 'application/javascript' });\n  res.end(\"Package.headers.headers.store(\" + JSON.stringify(req.headers) + \");\", 'utf8');\n});\n\n/*\n * After user has requested the headers (which were stored in headers.list\n * at the same time with the client's token, the below is called, which we\n * use to re-associate with the user's livedata session (see above)\n */\nMeteor.methods({\n  'headersToken': function(token) {\n    if (headers.list[token]) {\n      this._sessionData.headers = headers.list[token];\n      headerDep(this._sessionData).changed();\n      delete headers.list[token];\n    }\n  }\n});\n\n/*\n * Cleanup unclaimed headers\n */ \nMeteor.setInterval(function() {\n  for (key in headers.list)\n    if (parseInt(key) < new Date().getTime() - HEADERS_CLEANUP_TIME)\n      delete(headers.list[key]);\n}, HEADERS_CLEANUP_TIME);\n\n/*\n * Return the headerDep.  Create if necessary.\n */\nfunction headerDep(obj) {\n  if (!obj.headerDep)\n    obj.headerDep = new Deps.Dependency();\n  return obj.headerDep;\n}\n\n/*\n * Usage in a Meteor method: headers.get(this, 'host')\n */\nheaders.get = function(self, key) {\n  if (!self)\n    throw new Error('Must be called like this on the server: headers.get(this)');\n  var sessionData = self._session ? self._session.sessionData : self._sessionData;\n  headerDep(sessionData).depend();\n  if (!(sessionData && sessionData.headers))\n    return key ? undefined : {};\n  return key ? sessionData.headers[key] : sessionData.headers;\n}\n\nheaders.ready = function(self) {\n  if (!self)\n    throw new Error('Must be called like this on the server: headers.get(this)');\n  var sessionData = self._session ? self._session.sessionData : self._sessionData;\n  headerDep(sessionData).depend();\n  return Object.keys(sessionData.headers).length > 0;\n}\n\nheaders.getClientIP = function(self, proxyCount) {\n  if (!self)\n    throw new Error('Must be called like this on the server: headers.get(this)');\n  var sessionData = self._session ? self._session.sessionData : self._sessionData;\n  var chain = sessionData.headers['x-ip-chain'].split(',');\n  headerDep(sessionData).depend();\n  if (typeof(proxyCount) == 'undefined')\n    proxyCount = this.proxyCount;\n  return chain[chain.length - proxyCount - 1];\n}\n\n/*\n * Get the IP for the livedata connection used by a Method (see README.md)\n */\nheaders.methodClientIP = function(self, proxyCount) {\n  // convoluted way to find our session\n  // TODO, open an issue with Meteor to see if we can get easier access\n  var sessionData = self._session ? self._session.sessionData : self._sessionData;\n  var token, session;\n  token = new Date().getTime() + Math.random();\n  sessionData.tmpToken = token;\n  session = _.find(Meteor.server.sessions, function(session) {\n    return sessionData.tmpToken == token;\n  });\n\n  var chain = ipChain(session.socket.headers, session.socket);\n  if (typeof(proxyCount) == 'undefined')\n    proxyCount = this.proxyCount;\n  return chain[chain.length - proxyCount - 1];\n}\n"]}